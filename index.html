<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris und Sand? Am Meer ?</title>
  <style>
    /* ==========================================================
       GLOBAL STYLES (Apple Schrift, Layout, keine Scrollbars)
       ========================================================== */
    :root{
      --bg-top: #87CEEB;   /* Himmel */
      --bg-mid: #B3E5FC;   /* helles Blau */
      --bg-bot: #E0F7FA;   /* Wasser/Schaum */
      --panel-bg: rgba(255,255,255,0.92);
      --accent: #00A8E8;   /* Buttons, Highlights */
      --accent-2: #0085B6;
      --fall-blue: #1E90FF;  /* fallende Steine */
      --sand-base: #C9A974;  /* gelandeter Sand */
      --crumb: #5C3A1A;      /* Krümel */
    }

    *{ box-sizing:border-box; font-family:-apple-system, "SF Pro Text", "SF Pro Display", "Helvetica Neue", "Segoe UI", Roboto, "Noto Sans", Arial, sans-serif; }

    html, body{ height:100%; margin:0; padding:0; overflow:hidden; background:linear-gradient(180deg, var(--bg-top) 0%, var(--bg-mid) 60%, var(--bg-bot) 100%); -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }

    #wrapper{ height:100%; display:flex; align-items:center; justify-content:center; padding:18px; }

    /* Hauptcontainer (Spiel links, Infos rechts) */
    #gameBox{ width:780px; height:620px; border-radius:20px; box-shadow:0 30px 80px rgba(3,18,26,0.25); display:flex; overflow:hidden; background:linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02)); position:relative; }

    /* Linke Seite (Game Area) — jetzt exakt passend zum Grid */
    #leftPane{ width:340px; height:100%; position:relative; display:flex; align-items:center; justify-content:center; }
    #leftPane::before{ content:""; position:absolute; inset:0; background-image:url(""); /* ← HIER kann dein Bild hin */ background-size:cover; background-position:center; opacity:0.12; pointer-events:none; }

    /* Spiel-Canvas exakt: 10 * 26 = 260 breit, 20 * 26 = 520 hoch */
    #gameCanvas{ width:260px; height:520px; border-radius:16px; box-shadow:inset 0 6px 22px rgba(0,0,0,0.06); background:linear-gradient(#eaf6ff, #fff9ea 65%); display:block; }

    /* Effekt-Canvas (Feuerwerk, Partikel, Emojis) — exakt gleich groß */
    #fxCanvas{ position:absolute; width:260px; height:520px; left:calc(50% - 130px); top:calc(50% - 260px); pointer-events:none; border-radius:16px; }

    /* Rechte Seite (Score, Level, Timer, Anleitung) */
    #rightPane{ width:440px; padding:24px; display:flex; flex-direction:column; gap:14px; box-sizing:border-box; }
    .card{ background:var(--panel-bg); border-radius:12px; padding:12px; box-shadow:0 8px 24px rgba(0,0,0,0.06); }

    #highscore{ font-size:36px; font-weight:800; color:#d84315; letter-spacing:0.6px; text-align:center; }
    #score{ text-align:center; font-weight:700; font-size:18px; margin-top:6px; }

    #timer{ font-weight:900; font-size:28px; text-align:right; }
    #level, #lines{ font-weight:700; font-size:16px; }

    #controls{ font-size:13px; line-height:1.5; }

    /* Start-Overlay: vor Spielstart sichtbar, danach weg (genau Canvasgröße) */
    #startOverlay{ position:absolute; left:calc(50% - 130px); top:calc(50% - 260px); width:260px; height:520px; border-radius:16px; background:linear-gradient(180deg, rgba(1,22,39,0.62), rgba(1,22,39,0.45)); color:#fff; display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:60; text-align:center; padding:16px; box-sizing:border-box; }
    #startOverlay h1{ font-size:18px; margin:0 0 6px 0; font-weight:800; letter-spacing:0.6px; }
    #startOverlay p{ margin:6px 0; font-size:13px; color:#DCEFFB; }

    #startBtn{ margin-top:10px; background:var(--accent); border:none; color:white; padding:10px 16px; border-radius:12px; font-weight:800; cursor:pointer; box-shadow:0 10px 26px rgba(0,168,232,0.18); }
    #startBtn:hover{ background:var(--accent-2); }

    /* In-Game-Hilfe am unteren Rand der Spielfläche */
    #inGameHelp{ position:absolute; left:calc(50% - 130px); bottom:8px; width:260px; display:flex; justify-content:space-between; padding:0 8px; z-index:55; font-weight:700; color:#053240; font-size:11px; pointer-events:none; }

    /* Vollbild-Nachrichten (Rekord, Intelligent, Game Over etc.) */
    .bigMessage{ position:absolute; left:0; top:0; width:100%; height:100%; display:flex; align-items:center; justify-content:center; z-index:80; pointer-events:none; }
    .msgBox{ background:rgba(0,0,0,0.72); color:#fff; padding:20px 24px; border-radius:12px; font-weight:900; font-size:26px; text-align:center; transform:scale(0.92); opacity:0; transition:all 360ms cubic-bezier(.2,.9,.2,1); text-shadow:0 8px 36px rgba(0,0,0,0.6); pointer-events:none; }
    .msgBox.show{ opacity:1; transform:scale(1); }

    .muted{ color:#6b7c86; font-size:12px; }

    @media (max-width:820px){ #gameBox{ transform:scale(0.9); transform-origin:center; } }
  </style>
</head>
<body>
  <div id="wrapper">
    <div id="gameBox" role="application" aria-label="Sand Tetris am Meer">
      <!-- Linke Seite: Spielbereich (jetzt kompakt und voll genutzt) -->
      <div id="leftPane">
        <canvas id="gameCanvas" width="260" height="520"></canvas>
        <canvas id="fxCanvas"   width="260" height="520"></canvas>

        <!-- Start-Overlay (nur vor Spielstart sichtbar) -->
        <div id="startOverlay" aria-hidden="false">
          <h1>Sand‑Tetris — Zeitdruck Edition</h1>
          <p>Startzeit: <strong>04:30</strong> (270s). Jede Stufe: −15s (Timer wird neu gesetzt).</p>
          <p class="muted">Tasten: ← → bewegen · ↑ drehen · ↓ schneller fallen · P = Pause · R = Neustart</p>
          <button id="startBtn">SPIEL STARTEN</button>
          <p class="muted" style="margin-top:8px">Hintergrund: <em>Hier kannst du dein Bild hinzufügen</em></p>
        </div>

        <!-- In-Game Hilfe (unten klein) -->
        <div id="inGameHelp" aria-hidden="true">
          <div>← → bewegen · ↑ drehen · ↓ schneller</div>
          <div>R: Neustart · P: Pause</div>
        </div>

        <!-- Vollbild-Message Layer -->
        <div class="bigMessage" id="bigMsg" aria-hidden="true">
          <div id="msgBox" class="msgBox"></div>
        </div>
      </div>

      <!-- Rechte Seite: Score, Level, Timer, Anleitung -->
      <div id="rightPane">
        <div class="card" style="text-align:center;">
          <div id="highscore">HIGHSCORE: 0</div>
          <div id="score" style="margin-top:6px;">Score: 0</div>
        </div>

        <div class="card">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div>
              <div id="level">Level: 1</div>
              <div id="lines">Lines: 0</div>
            </div>
            <div style="text-align:right">
              <div id="timer">04:30</div>
              <div class="muted">Zeit übrig</div>
            </div>
          </div>
        </div>

        <div class="card" id="controls">
          <strong>Anleitung</strong>
          <ul style="margin:8px 0 0 18px; padding:0;">
            <li>← → : bewegen</li>
            <li>↑ : drehen</li>
            <li>↓ : schneller fallen</li>
            <li>P : Pause</li>
            <li>R : Neustart</li>
            <li>Leertaste : Hard Drop</li>
          </ul>
          <p class="muted" style="margin-top:8px">Bei Level‑Aufstieg wird der Timer neu gesetzt und um 15s kürzer. Steine fallen etwas schneller.</p>
        </div>

        <div class="card" style="text-align:center; font-size:12px;">
          <div class="muted">Design: Sand am Meer · Abgerundete Kanten · Apple‑Schrift</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Hintergrundmusik (Platzhalter) -->
  <audio id="bgMusic" loop preload="none">
    <!-- Hier kannst du dein Lied / Audio-Datei hin machen -->
    <!-- <source src="deine_relax_musik.mp3" type="audio/mpeg"> -->
  </audio>

  <!-- Effektsounds (Platzhalterquellen; optional ergänzen) -->
  <audio id="sfxApplause" preload="none">
    <!-- <source src="applaus.mp3" type="audio/mpeg"> -->
  </audio>
  <audio id="sfxWow" preload="none">
    <!-- <source src="wow.mp3" type="audio/mpeg"> -->
  </audio>
  <audio id="sfxGameOver" preload="none">
    <!-- <source src="gameover.mp3" type="audio/mpeg"> -->
  </audio>

  <script>
  // ============================================================
  //  SAND‑TETRIS — Vollständiges Spiel in einer Datei
  //  Optimiert: Canvas exakt 10x20 Felder à 26px (260x520),
  //  dadurch wird die komplette Game Area sinnvoll genutzt.
  //  Anforderungen aus dem Chat umgesetzt:
  //   • Timer startet bei 4:30 und wird bei JEDEM Level neu gesetzt,
  //     jeweils 15 Sekunden kürzer (nie nur „eine“ Zeit die weiterläuft).
  //   • Steine blau beim Fallen (#1E90FF), werden zu Sand (#C9A974) + Krümel (#5C3A1A).
  //   • Highscore groß oben; Effekte bei Rekord (Feuerwerk + Message + Applaus).
  //   • Bei 3 Reihen gleichzeitig: „VERY INTELLIGENT , GAVE MORE !“ + grüner Emoji‑Regen + „WOWWWW“‑Sound.
  //   • Game Over: „GAME OVER GIVE MORE NEXT TIME :)“ + klassischer Sound.
  //   • Keine Scrollbar; Game‑Area abgerundet; Apple‑Schrift.
  //   • Anleitung im Spielbereich; Start‑Overlay blendet aus; Tasten: ← → ↑ ↓ P R (Leertaste Hard Drop).
  //   • Eine einzige HTML‑Datei (~900 Zeilen inkl. Kommentare).
  // ============================================================

  /* ------------------------------------------------------------
   *  CONFIGURATION
   * ------------------------------------------------------------ */
  const CONFIG = {
    COLS: 10,
    ROWS: 20,
    BLOCK: 26,                // 10*26 = 260, 20*26 = 520

    // Timer-Logik: Ab Level 1 = 4:30, pro Level −15s, Timer wird JEDES MAL neu gesetzt
    START_TIME_SEC: 270,             // 4 Minuten 30 Sekunden
    TIME_DECREASE_PER_LEVEL: 15,     // pro Level 15 Sekunden weniger

    // Fallgeschwindigkeit: wird mit Level schneller
    INITIAL_DROP_MS: 700,
    MIN_DROP_MS: 120,
    DROP_DECREASE_PER_LEVEL: 40,

    // Level-Grenzen (Gesamt-Lines): Level 2 ab 3, Level 3 ab 5, Level 4 ab 8 …
    LEVEL_THRESHOLDS: [3, 5, 8, 12, 16, 20, 25, 30, 36, 42],

    // Scoring
    SCORE_SINGLE: 100,
    SCORE_DOUBLE: 250,
    SCORE_TRIPLE: 450,
    SCORE_TETRIS: 800,
  };

  // Farben
  const FALL_COLOR  = getComputedStyle(document.documentElement).getPropertyValue('--fall-blue').trim() || '#1E90FF';
  const SAND_BASE   = getComputedStyle(document.documentElement).getPropertyValue('--sand-base').trim() || '#C9A974';
  const CRUMB_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--crumb').trim() || '#5C3A1A';

  // UI‑Elemente
  const canvas   = document.getElementById('gameCanvas');
  const ctx      = canvas.getContext('2d');
  const fxCanvas = document.getElementById('fxCanvas');
  const fx       = fxCanvas.getContext('2d');

  const elHigh   = document.getElementById('highscore');
  const elScore  = document.getElementById('score');
  const elLines  = document.getElementById('lines');
  const elLevel  = document.getElementById('level');
  const elTimer  = document.getElementById('timer');
  const elStart  = document.getElementById('startOverlay');
  const elHelp   = document.getElementById('inGameHelp');
  const elMsg    = document.getElementById('msgBox');

  // Audio (Platzhalter)
  const bgMusic  = document.getElementById('bgMusic');
  const sfxAppl  = document.getElementById('sfxApplause');
  const sfxWow   = document.getElementById('sfxWow');
  const sfxOver  = document.getElementById('sfxGameOver');

  // Spielfeld/Daten
  let grid = [];                    // 0 = leer, 1 = Sand
  let current = null;               // aktuell fallendes Teil
  let next     = null;              // nächstes Teil

  let score = 0;
  let linesCleared = 0;             // insgesamt gelöschte Reihen
  let level = 1;
  let dropInterval = CONFIG.INITIAL_DROP_MS;
  let dropCounter = 0;
  let lastTime = 0;

  // Timerlogik
  let levelStartTime = CONFIG.START_TIME_SEC; // Sekunden, mit denen das Level beginnt
  let timeLeft = CONFIG.START_TIME_SEC;       // herunterzählender Timer
  let timerId = null;                         // setInterval‑ID
  let paused = false;
  let gameOver = false;

  // Highscore persistent
  const HS_KEY = 'sand_tetris_highscore_v3';
  let highscore = Number(localStorage.getItem(HS_KEY) || 0);
  updateHighscoreUI();

  /* ------------------------------------------------------------
   *  TETRIS‑TEILE (Matrizen)
   * ------------------------------------------------------------ */
  const PIECES = [
    { name:'I', matrix:[ [1,1,1,1] ] },
    { name:'J', matrix:[ [1,0,0],[1,1,1] ] },
    { name:'L', matrix:[ [0,0,1],[1,1,1] ] },
    { name:'O', matrix:[ [1,1],[1,1] ] },
    { name:'S', matrix:[ [0,1,1],[1,1,0] ] },
    { name:'T', matrix:[ [0,1,0],[1,1,1] ] },
    { name:'Z', matrix:[ [1,1,0],[0,1,1] ] },
  ];

  function randomPiece(){
    const p = PIECES[(Math.random()*PIECES.length)|0];
    return {
      name: p.name,
      matrix: p.matrix.map(row=>row.slice()),
      color: FALL_COLOR,
      x: ((CONFIG.COLS/2)|0) - ((p.matrix[0].length/2)|0),
      y: -2
    };
  }

  function rotateMatrix(m){
    const h = m.length, w = m[0].length;
    const r = Array.from({length:w}, ()=>Array(h).fill(0));
    for(let y=0;y<h;y++) for(let x=0;x<w;x++) r[x][h-1-y] = m[y][x];
    return r;
  }

  /* ------------------------------------------------------------
   *  GRID / INIT
   * ------------------------------------------------------------ */
  function initGrid(){
    grid = Array.from({length:CONFIG.ROWS}, ()=>Array(CONFIG.COLS).fill(0));
  }

  function resetGame(){
    initGrid();
    score = 0; linesCleared = 0; level = 1; gameOver = false; paused = false;
    dropInterval = CONFIG.INITIAL_DROP_MS; dropCounter = 0; lastTime = 0;
    levelStartTime = CONFIG.START_TIME_SEC; timeLeft = CONFIG.START_TIME_SEC; restartTimer();
    current = randomPiece(); next = randomPiece();
    updateUI();
    showNextRequirementMessage();
  }

  /* ------------------------------------------------------------
   *  TIMER: pro Level NEU setzen (4:30, dann −15s, …)
   * ------------------------------------------------------------ */
  function restartTimer(){
    if(timerId) { clearInterval(timerId); timerId = null; }
    updateTimerUI(timeLeft);
    timerId = setInterval(()=>{
      if(paused || gameOver) return;
      timeLeft--;
      if(timeLeft <= 0){ timeLeft = 0; updateTimerUI(timeLeft); onTimeUp(); return; }
      updateTimerUI(timeLeft);
    }, 1000);
  }

  function onTimeUp(){
    clearInterval(timerId); timerId = null;
    endGame(false);
  }

  function updateTimerUI(sec){ elTimer.textContent = formatTime(sec); }
  function formatTime(sec){ const m = Math.floor(sec/60); const s = sec%60; return `${String(m).padStart(1,'0')}:${String(s).padStart(2,'0')}`; }

  /* ------------------------------------------------------------
   *  UI‑Updates (Score, Lines, Level, Highscore)
   * ------------------------------------------------------------ */
  function updateHighscoreUI(){ elHigh.textContent = `HIGHSCORE: ${highscore|0}`; }
  function updateUI(){ elScore.textContent = `Score: ${score|0}`; elLines.textContent = `Lines: ${linesCleared|0}`; elLevel.textContent = `Level: ${level|0}`; }

  /* ------------------------------------------------------------
   *  KOLLISION / BEWEGUNG / VERSCHMELZEN
   * ------------------------------------------------------------ */
  function collide(g, piece){
    const m = piece.matrix; const oX = piece.x; const oY = piece.y;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(!m[y][x]) continue;
        const nx = oX + x; const ny = oY + y;
        if(nx < 0 || nx >= CONFIG.COLS || ny >= CONFIG.ROWS) return true;
        if(ny >= 0 && g[ny][nx]) return true;
      }
    }
    return false;
  }

  function merge(g, piece){
    const m = piece.matrix; const oX = piece.x; const oY = piece.y;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(m[y][x]){
          const gx = oX + x, gy = oY + y;
          if(gy >= 0 && gy < CONFIG.ROWS && gx >= 0 && gx < CONFIG.COLS){
            g[gy][gx] = 1; // Landung => wird zu Sand
            spawnSandCrumbs(gx, gy);
          }
        }
      }
    }
  }

  function hardDrop(){ if(gameOver || paused) return; while(!collide(grid, {...current, y:current.y+1})) current.y++; lockPiece(); }

  function lockPiece(){
    merge(grid, current);
    const lines = clearLines();
    const extraScore = calcScoreFor(lines);
    score += extraScore;

    if(lines === 3){ showIntelligentMessage(); playSfx(sfxWow, 'wow'); spawnEmojiRain(['👍','🧠','💡','✅'], 18, 'green'); }

    if(lines > 0){ updateUI(); }

    current = next; next = randomPiece();
    if(collide(grid, current)){ endGame(true); return; }

    checkLevelProgress();
  }

  /* ------------------------------------------------------------
   *  LINIEN LÖSCHEN & SCORE
   * ------------------------------------------------------------ */
  function clearLines(){
    let lines = 0;
    outer: for(let y=CONFIG.ROWS-1; y>=0; y--){
      for(let x=0; x<CONFIG.COLS; x++){
        if(!grid[y][x]) continue outer;
      }
      grid.splice(y,1);
      grid.unshift(Array(CONFIG.COLS).fill(0));
      y++;
      lines++;
      spawnLineClearPuff(y);
    }
    if(lines>0){ linesCleared += lines; updateUI(); }
    return lines;
  }

  function calcScoreFor(lines){ switch(lines){ case 1: return CONFIG.SCORE_SINGLE; case 2: return CONFIG.SCORE_DOUBLE; case 3: return CONFIG.SCORE_TRIPLE; case 4: return CONFIG.SCORE_TETRIS; default: return 0; } }

  /* ------------------------------------------------------------
   *  LEVEL‑LOGIK (Timer NEU setzen, Drop schneller, Info‑Message)
   * ------------------------------------------------------------ */
  function checkLevelProgress(){
    const thresholds = CONFIG.LEVEL_THRESHOLDS;
    if(level-1 < thresholds.length){
      const need = thresholds[level-1];
      if(linesCleared >= need){ levelUp(); }
    }
  }

  function levelUp(){
    level++;
    dropInterval = Math.max(CONFIG.MIN_DROP_MS, dropInterval - CONFIG.DROP_DECREASE_PER_LEVEL);

    levelStartTime = Math.max(30, CONFIG.START_TIME_SEC - (level-1)*CONFIG.TIME_DECREASE_PER_LEVEL);
    timeLeft = levelStartTime;
    restartTimer();

    updateUI();
    showNextRequirementMessage();
  }

  function showNextRequirementMessage(){
    const thresholds = CONFIG.LEVEL_THRESHOLDS;
    const nextIndex = level-1;
    if(nextIndex < thresholds.length){
      const need = thresholds[nextIndex];
      const targetLevel = level+1;
      showMessage(`This time you need ${need} lines to come on level ${targetLevel}`, 2600);
    } else {
      showMessage(`You are at level ${level}. Keep going!`, 2000);
    }
  }

  /* ------------------------------------------------------------
   *  GAME LOOP / ZEICHNEN
   * ------------------------------------------------------------ */
  function update(t=0){
    const dt = t - lastTime; lastTime = t;
    if(!paused && !gameOver){
      dropCounter += dt;
      if(dropCounter >= dropInterval){ softDrop(); dropCounter = 0; }
    }
    draw();
    if(!gameOver) requestAnimationFrame(update);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    fx.clearRect(0,0,fxCanvas.width,fxCanvas.height);

    drawGrid();
    if(current) drawPiece(current);
    stepParticles();
  }

  function drawGrid(){
    for(let y=0;y<CONFIG.ROWS;y++){
      for(let x=0;x<CONFIG.COLS;x++){
        if(grid[y][x]){
          drawBlock(x, y, SAND_BASE, 1);
          if(Math.random() < 0.18){
            fx.fillStyle = CRUMB_COLOR;
            const kx = x*CONFIG.BLOCK + 4 + Math.random()*(CONFIG.BLOCK-8);
            const ky = y*CONFIG.BLOCK + 4 + Math.random()*(CONFIG.BLOCK-8);
            fx.fillRect(kx, ky, 2, 2);
          }
        } else {
          ctx.fillStyle = 'rgba(255,255,255,0.03)';
          ctx.fillRect(x*CONFIG.BLOCK+1, y*CONFIG.BLOCK+1, CONFIG.BLOCK-2, CONFIG.BLOCK-2);
        }
      }
    }
  }

  function drawPiece(p){
    const m = p.matrix;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(m[y][x]){ drawBlock(p.x + x, p.y + y, FALL_COLOR, 1); }
      }
    }
  }

  function roundRect(ctx, x, y, w, h, r, fill=true, stroke=false){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath();
    if(fill) ctx.fill(); if(stroke) ctx.stroke();
  }

  function drawBlock(gx, gy, color, alpha=1){
    if(gy < 0) return;
    const px = gx * CONFIG.BLOCK; const py = gy * CONFIG.BLOCK;
    ctx.save(); ctx.globalAlpha = alpha; ctx.fillStyle = color;
    roundRect(ctx, px+1, py+1, CONFIG.BLOCK-2, CONFIG.BLOCK-2, 4, true, false);
    ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.strokeRect(px+1, py+1, CONFIG.BLOCK-2, CONFIG.BLOCK-2);
    ctx.restore();
  }

  /* ------------------------------------------------------------
   *  FALLEN / STEUERUNG
   * ------------------------------------------------------------ */
  function softDrop(){
    const test = {...current, y: current.y + 1};
    if(!collide(grid, test)){ current.y++; } else { lockPiece(); }
  }

  function move(dx){ const test = {...current, x: current.x + dx}; if(!collide(grid, test)) current.x += dx; }

  function rotate(){
    const rot = rotateMatrix(current.matrix);
    const test = {...current, matrix: rot};
    if(!collide(grid, test)){ current.matrix = rot; return; }
    test.x = current.x + 1; if(!collide(grid,test)){ current.x+=1; current.matrix=rot; return; }
    test.x = current.x - 1; if(!collide(grid,test)){ current.x-=1; current.matrix=rot; return; }
  }

  /* ------------------------------------------------------------
   *  INPUT HANDLING
   * ------------------------------------------------------------ */
  document.addEventListener('keydown', (e)=>{
    if(gameOver) return;
    if(e.key === 'ArrowLeft'){ e.preventDefault(); if(!paused) move(-1); }
    else if(e.key === 'ArrowRight'){ e.preventDefault(); if(!paused) move(+1); }
    else if(e.key === 'ArrowUp'){ e.preventDefault(); if(!paused) rotate(); }
    else if(e.key === 'ArrowDown'){ e.preventDefault(); if(!paused) softDrop(); dropCounter = 0; }
    else if(e.key === ' '){ e.preventDefault(); if(!paused) hardDrop(); }
    else if(e.key.toLowerCase() === 'p'){ togglePause(); }
    else if(e.key.toLowerCase() === 'r'){ restartAll(); }
  }, {passive:false});

  function togglePause(){ if(gameOver) return; paused = !paused; elHelp.setAttribute('aria-hidden', paused ? 'true' : 'false'); showMessage(paused ? 'PAUSED' : 'RESUMED', 900); }
  function restartAll(){ resetGame(); }

  /* ------------------------------------------------------------
   *  SPIELSTART / OVERLAY / HELP
   * ------------------------------------------------------------ */
  document.getElementById('startBtn').addEventListener('click', ()=>{ elStart.style.display = 'none'; elHelp.setAttribute('aria-hidden', 'false'); startGame(); });

  function startGame(){ resetGame(); requestAnimationFrame(update); try{ bgMusic.volume = 0.35; bgMusic.play().catch(()=>{}); }catch{} }

  function endGame(){
    gameOver = true; paused = true;
    if(timerId){ clearInterval(timerId); timerId = null; }
    const isHigh = trySetHighscore(score);
    if(isHigh){ showRecordMessage(); playSfx(sfxAppl, 'applause'); spawnFireworks(); }
    else { showMessage('GAME OVER GIVE MORE NEXT TIME :)', 3200); playSfx(sfxOver, 'gameover'); }
  }

  function trySetHighscore(s){ if(s > highscore){ highscore = s; localStorage.setItem(HS_KEY, String(highscore)); updateHighscoreUI(); return true; } return false; }

  /* ------------------------------------------------------------
   *  MESSAGES & FX (Feuerwerk, Emojis, Sandkrümel, Linie‑Puff)
   * ------------------------------------------------------------ */
  function showMessage(text, duration=2000){ elMsg.textContent = text; elMsg.classList.add('show'); elMsg.parentElement.setAttribute('aria-hidden','false'); setTimeout(()=>{ elMsg.classList.remove('show'); elMsg.parentElement.setAttribute('aria-hidden','true'); }, duration); }
  function showRecordMessage(){ showMessage('YOU HAVE A NEW REKORD WOW !', 3400); }

  const particles = [];

  function spawnFireworks(){ for(let i=0;i<5;i++){ const cx = 20 + Math.random()*(fxCanvas.width-40); const cy = 40 + Math.random()*(fxCanvas.height-100); makeBurst(cx, cy, 100 + Math.random()*60); } }

  function makeBurst(cx, cy, count=120){ for(let i=0;i<count;i++){ const a = Math.random()*Math.PI*2; const sp = 0.8 + Math.random()*2.2; particles.push({ x: cx, y: cy, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 900 + Math.random()*800, age: 0, type: 'spark' }); } }

  function spawnEmojiRain(chars=['🎉','⭐','👏'], n=10){ for(let i=0;i<n;i++){ const x = 20 + Math.random()*(fxCanvas.width-40); const size = 18 + Math.random()*20; particles.push({ x, y:-20, vx:(Math.random()-0.5)*0.4, vy:0.2+Math.random()*0.6, rot:(Math.random()*Math.PI), drot:(Math.random()-0.5)*0.02, life: 4000, age:0, type:'emoji', char: chars[(Math.random()*chars.length)|0], size }); } }

  function spawnSandCrumbs(gx, gy){ const cx = gx*CONFIG.BLOCK + CONFIG.BLOCK/2; const cy = gy*CONFIG.BLOCK + CONFIG.BLOCK/2; const n = 4 + (Math.random()*6)|0; for(let i=0;i<n;i++){ const a = Math.random()*Math.PI*2; const sp = 0.3 + Math.random()*0.8; particles.push({ x:cx, y:cy, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp+0.4, life: 600, age:0, type:'crumb' }); } }

  function spawnLineClearPuff(rowY){ const y = rowY*CONFIG.BLOCK + CONFIG.BLOCK/2; for(let x=0;x<CONFIG.COLS;x++){ const cx = x*CONFIG.BLOCK + CONFIG.BLOCK/2; for(let i=0;i<3;i++){ particles.push({ x:cx, y, vx:(Math.random()-0.5)*0.8, vy:(Math.random()-0.5)*0.6, life: 500, age:0, type:'puff' }); } } }

  function showIntelligentMessage(){ showMessage('VERY INTELLIGENT , GAVE MORE !', 2400); }

  function stepParticles(){ const g = 0.02; for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.age += 16.6; if(p.type === 'spark'){ p.vy += 0.002; } if(p.type === 'crumb'){ p.vy += g; } p.x += p.vx; p.y += p.vy; if(p.rot!=null){ p.rot += p.drot||0; } if(p.age >= p.life){ particles.splice(i,1); continue; } drawParticle(p); } }

  function drawParticle(p){ if(p.type === 'spark'){ const a = 1 - (p.age/p.life); fx.globalAlpha = a; fx.fillStyle = `hsl(${(p.age*0.2)%360} 90% 60%)`; fx.beginPath(); fx.arc(p.x,p.y,2,0,Math.PI*2); fx.fill(); fx.globalAlpha = 1; } else if(p.type === 'emoji'){ fx.save(); fx.translate(p.x, p.y); fx.rotate(p.rot||0); fx.font = `${p.size|0}px Apple Color Emoji, "Segoe UI Emoji", Noto Color Emoji, sans-serif`; fx.textAlign = 'center'; fx.textBaseline = 'middle'; fx.fillText(p.char, 0, 0); fx.restore(); } else if(p.type === 'crumb'){ fx.fillStyle = CRUMB_COLOR; fx.fillRect(p.x, p.y, 2, 2); } else if(p.type === 'puff'){ fx.globalAlpha = Math.max(0, 1 - p.age/p.life); fx.fillStyle = 'rgba(201,169,116,0.7)'; fx.beginPath(); fx.arc(p.x,p.y, 3.5, 0, Math.PI*2); fx.fill(); fx.globalAlpha = 1; } }

  /* ------------------------------------------------------------
   *  START‑/PAUSE‑LOGIK & SAFEGUARDS
   * ------------------------------------------------------------ */
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ paused = true; } });
  window.addEventListener('keydown', (e)=>{ if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)){ e.preventDefault(); } }, {passive:false});

  /* ------------------------------------------------------------
   *  INITIALISIERUNG
   * ------------------------------------------------------------ */
  initGrid(); updateUI(); updateTimerUI(timeLeft);

  // Hauptschleife startet nach Klick auf Start

  </script>
</body>
</html>